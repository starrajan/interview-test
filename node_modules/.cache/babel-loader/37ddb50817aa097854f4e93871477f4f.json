{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sendAPDU = void 0;\n\nvar _rxjs = require(\"rxjs\");\n\nvar _logs = require(\"@ledgerhq/logs\");\n\nconst TagId = 0x05;\n\nfunction chunkBuffer(buffer, sizeForIndex) {\n  const chunks = [];\n\n  for (let i = 0, size = sizeForIndex(0); i < buffer.length; i += size, size = sizeForIndex(i)) {\n    chunks.push(buffer.slice(i, i + size));\n  }\n\n  return chunks;\n}\n\nconst sendAPDU = (write, apdu, mtuSize) => {\n  const chunks = chunkBuffer(apdu, i => mtuSize - (i === 0 ? 5 : 3)).map((buffer, i) => {\n    const head = Buffer.alloc(i === 0 ? 5 : 3);\n    head.writeUInt8(TagId, 0);\n    head.writeUInt16BE(i, 1);\n\n    if (i === 0) {\n      head.writeUInt16BE(apdu.length, 3);\n    }\n\n    return Buffer.concat([head, buffer]);\n  });\n  return _rxjs.Observable.create(o => {\n    let terminated = false;\n\n    async function main() {\n      for (const chunk of chunks) {\n        if (terminated) return;\n        await write(chunk);\n      }\n    }\n\n    main().then(() => {\n      terminated = true;\n      o.complete();\n    }, e => {\n      terminated = true;\n      (0, _logs.log)(\"ble-error\", \"sendAPDU failure \" + String(e));\n      o.error(e);\n    });\n\n    const unsubscribe = () => {\n      if (!terminated) {\n        (0, _logs.log)(\"ble-verbose\", \"sendAPDU interruption\");\n        terminated = true;\n      }\n    };\n\n    return unsubscribe;\n  });\n};\n\nexports.sendAPDU = sendAPDU;","map":{"version":3,"sources":["../../src/ble/sendAPDU.js"],"names":["TagId","chunks","i","size","sizeForIndex","buffer","sendAPDU","mtuSize","head","Buffer","apdu","o","terminated","write","main","e","String","unsubscribe"],"mappings":";;;;;;;AAEA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,MAAMA,KAAK,GAAX,IAAA;;AAEA,SAAA,WAAA,CAAA,MAAA,EAAA,YAAA,EAGiB;AACf,QAAMC,MAAM,GAAZ,EAAA;;AACA,OACE,IAAIC,CAAC,GAAL,CAAA,EAAWC,IAAI,GAAGC,YAAY,CADhC,CACgC,CADhC,EAEEF,CAAC,GAAGG,MAAM,CAFZ,MAAA,EAGEH,CAAC,IAADA,IAAAA,EAAWC,IAAI,GAAGC,YAAY,CAHhC,CAGgC,CAHhC,EAIE;AACAH,IAAAA,MAAM,CAANA,IAAAA,CAAYI,MAAM,CAANA,KAAAA,CAAAA,CAAAA,EAAgBH,CAAC,GAA7BD,IAAYI,CAAZJ;AACD;;AACD,SAAA,MAAA;AACD;;AAEM,MAAMK,QAAQ,GAAG,CAAA,KAAA,EAAA,IAAA,EAAA,OAAA,KAID;AACrB,QAAML,MAAM,GAAG,WAAW,CAAA,IAAA,EAAQC,CAAD,IAAOK,OAAO,IAAIL,CAAC,KAADA,CAAAA,GAAAA,CAAAA,GAApC,CAAgC,CAArB,CAAX,CAAA,GAAA,CACb,CAAA,MAAA,EAAA,CAAA,KAAe;AACb,UAAMM,IAAI,GAAGC,MAAM,CAANA,KAAAA,CAAaP,CAAC,KAADA,CAAAA,GAAAA,CAAAA,GAA1B,CAAaO,CAAb;AACAD,IAAAA,IAAI,CAAJA,UAAAA,CAAAA,KAAAA,EAAAA,CAAAA;AACAA,IAAAA,IAAI,CAAJA,aAAAA,CAAAA,CAAAA,EAAAA,CAAAA;;AACA,QAAIN,CAAC,KAAL,CAAA,EAAa;AACXM,MAAAA,IAAI,CAAJA,aAAAA,CAAmBE,IAAI,CAAvBF,MAAAA,EAAAA,CAAAA;AACD;;AACD,WAAOC,MAAM,CAANA,MAAAA,CAAc,CAAA,IAAA,EAArB,MAAqB,CAAdA,CAAP;AARJ,GAAe,CAAf;AAYA,SAAO,KAAA,CAAA,UAAA,CAAA,MAAA,CAAmBE,CAAD,IAAO;AAC9B,QAAIC,UAAU,GAAd,KAAA;;AAEA,mBAAA,IAAA,GAAsB;AACpB,WAAK,MAAL,KAAA,IAAA,MAAA,EAA4B;AAC1B,YAAA,UAAA,EAAgB;AAChB,cAAMC,KAAK,CAAX,KAAW,CAAX;AACD;AACF;;AAEDC,IAAAA,IAAI,GAAJA,IAAAA,CACE,MAAM;AACJF,MAAAA,UAAU,GAAVA,IAAAA;AACAD,MAAAA,CAAC,CAADA,QAAAA;AAHJG,KAAAA,EAKGC,CAAD,IAAO;AACLH,MAAAA,UAAU,GAAVA,IAAAA;AACA,OAAA,GAAA,KAAA,CAAA,GAAA,EAAA,WAAA,EAAiB,sBAAsBI,MAAM,CAA7C,CAA6C,CAA7C;AACAL,MAAAA,CAAC,CAADA,KAAAA,CAAAA,CAAAA;AARJG,KAAAA;;AAYA,UAAMG,WAAW,GAAG,MAAM;AACxB,UAAI,CAAJ,UAAA,EAAiB;AACf,SAAA,GAAA,KAAA,CAAA,GAAA,EAAA,aAAA,EAAA,uBAAA;AACAL,QAAAA,UAAU,GAAVA,IAAAA;AACD;AAJH,KAAA;;AAOA,WAAA,WAAA;AA7BF,GAAO,CAAP;AAjBK,CAAA","sourcesContent":["// @flow\n\nimport { Observable } from \"rxjs\";\nimport { log } from \"@ledgerhq/logs\";\n\nconst TagId = 0x05;\n\nfunction chunkBuffer(\n  buffer: Buffer,\n  sizeForIndex: (number) => number\n): Array<Buffer> {\n  const chunks = [];\n  for (\n    let i = 0, size = sizeForIndex(0);\n    i < buffer.length;\n    i += size, size = sizeForIndex(i)\n  ) {\n    chunks.push(buffer.slice(i, i + size));\n  }\n  return chunks;\n}\n\nexport const sendAPDU = (\n  write: (Buffer) => Promise<void>,\n  apdu: Buffer,\n  mtuSize: number\n): Observable<void> => {\n  const chunks = chunkBuffer(apdu, (i) => mtuSize - (i === 0 ? 5 : 3)).map(\n    (buffer, i) => {\n      const head = Buffer.alloc(i === 0 ? 5 : 3);\n      head.writeUInt8(TagId, 0);\n      head.writeUInt16BE(i, 1);\n      if (i === 0) {\n        head.writeUInt16BE(apdu.length, 3);\n      }\n      return Buffer.concat([head, buffer]);\n    }\n  );\n\n  return Observable.create((o) => {\n    let terminated = false;\n\n    async function main() {\n      for (const chunk of chunks) {\n        if (terminated) return;\n        await write(chunk);\n      }\n    }\n\n    main().then(\n      () => {\n        terminated = true;\n        o.complete();\n      },\n      (e) => {\n        terminated = true;\n        log(\"ble-error\", \"sendAPDU failure \" + String(e));\n        o.error(e);\n      }\n    );\n\n    const unsubscribe = () => {\n      if (!terminated) {\n        log(\"ble-verbose\", \"sendAPDU interruption\");\n        terminated = true;\n      }\n    };\n\n    return unsubscribe;\n  });\n};\n"]},"metadata":{},"sourceType":"script"}