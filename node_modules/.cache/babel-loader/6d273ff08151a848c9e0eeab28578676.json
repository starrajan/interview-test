{"ast":null,"code":"/* eslint-disable prefer-template */\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { DisconnectedDevice, TransportOpenUserCancelled } from \"@ledgerhq/errors\";\nimport { getBluetoothServiceUuids, getInfosForServiceUuid } from \"@ledgerhq/devices\";\nimport { sendAPDU } from \"@ledgerhq/devices/lib/ble/sendAPDU\";\nimport { receiveAPDU } from \"@ledgerhq/devices/lib/ble/receiveAPDU\";\nimport { log } from \"@ledgerhq/logs\";\nimport { Observable, defer, merge, from } from \"rxjs\";\nimport { share, ignoreElements, first, map, tap } from \"rxjs/operators\";\nimport { monitorCharacteristic } from \"./monitorCharacteristic\";\n\nconst requiresBluetooth = () => {\n  // $FlowFixMe\n  const {\n    bluetooth\n  } = navigator;\n\n  if (typeof bluetooth === \"undefined\") {\n    throw new Error(\"web bluetooth not supported\");\n  }\n\n  return bluetooth;\n};\n\nconst availability = () => Observable.create(observer => {\n  const bluetooth = requiresBluetooth();\n\n  const onAvailabilityChanged = e => {\n    observer.next(e.value);\n  };\n\n  bluetooth.addEventListener(\"availabilitychanged\", onAvailabilityChanged);\n  let unsubscribed = false;\n  bluetooth.getAvailability().then(available => {\n    if (!unsubscribed) {\n      observer.next(available);\n    }\n  });\n  return () => {\n    unsubscribed = true;\n    bluetooth.removeEventListener(\"availabilitychanged\", onAvailabilityChanged);\n  };\n});\n\nconst transportsCache = {};\n\nconst requestDeviceParam = () => ({\n  filters: getBluetoothServiceUuids().map(uuid => ({\n    services: [uuid]\n  }))\n});\n\nconst retrieveService = async device => {\n  if (!device.gatt) throw new Error(\"bluetooth gatt not found\");\n  const [service] = await device.gatt.getPrimaryServices();\n  if (!service) throw new Error(\"bluetooth service not found\");\n  const infos = getInfosForServiceUuid(service.uuid);\n  if (!infos) throw new Error(\"bluetooth service infos not found\");\n  return [service, infos];\n};\n\nasync function open(deviceOrId, needsReconnect) {\n  let device;\n\n  if (typeof deviceOrId === \"string\") {\n    if (transportsCache[deviceOrId]) {\n      log(\"ble-verbose\", \"Transport in cache, using that.\");\n      return transportsCache[deviceOrId];\n    }\n\n    const bluetooth = requiresBluetooth(); // TODO instead we should \"query\" the device by its ID\n\n    device = await bluetooth.requestDevice(requestDeviceParam());\n  } else {\n    device = deviceOrId;\n  }\n\n  if (!device.gatt.connected) {\n    log(\"ble-verbose\", \"not connected. connecting...\");\n    await device.gatt.connect();\n  }\n\n  const [service, infos] = await retrieveService(device);\n  const {\n    deviceModel,\n    writeUuid,\n    notifyUuid\n  } = infos;\n  const [writeC, notifyC] = await Promise.all([service.getCharacteristic(writeUuid), service.getCharacteristic(notifyUuid)]);\n  const notifyObservable = monitorCharacteristic(notifyC).pipe(tap(value => {\n    log(\"ble-frame\", \"<= \" + value.toString(\"hex\"));\n  }), share());\n  const notif = notifyObservable.subscribe();\n  const transport = new BluetoothTransport(device, writeC, notifyObservable, deviceModel);\n\n  if (!device.gatt.connected) {\n    throw new DisconnectedDevice();\n  } // eslint-disable-next-line require-atomic-updates\n\n\n  transportsCache[transport.id] = transport;\n\n  const onDisconnect = e => {\n    console.log(\"onDisconnect!\", e);\n    delete transportsCache[transport.id];\n    transport.notYetDisconnected = false;\n    notif.unsubscribe();\n    device.removeEventListener(\"gattserverdisconnected\", onDisconnect);\n    log(\"ble-verbose\", `BleTransport(${transport.id}) disconnected`);\n    transport.emit(\"disconnect\", e);\n  };\n\n  device.addEventListener(\"gattserverdisconnected\", onDisconnect);\n  let beforeMTUTime = Date.now();\n\n  try {\n    await transport.inferMTU();\n  } finally {\n    let afterMTUTime = Date.now(); // workaround for #279: we need to open() again if we come the first time here,\n    // to make sure we do a disconnect() after the first pairing time\n    // because of a firmware bug\n\n    if (afterMTUTime - beforeMTUTime < 1000) {\n      needsReconnect = false; // (optim) there is likely no new pairing done because mtu answer was fast.\n    }\n\n    if (needsReconnect) {\n      await device.gatt.disconnect(); // necessary time for the bonding workaround\n\n      await new Promise(s => setTimeout(s, 4000));\n    }\n  }\n\n  if (needsReconnect) {\n    return open(device, false);\n  }\n\n  return transport;\n}\n/**\n * react-native bluetooth BLE implementation\n * @example\n * import BluetoothTransport from \"@ledgerhq/hw-transport-web-ble\";\n */\n\n\nexport default class BluetoothTransport extends Transport {\n  /**\n   * observe event with { available: bool, type: string }\n   * (available is generic, type is specific)\n   * an event is emit once and then each time it changes\n   */\n\n  /**\n   * Scan for Ledger Bluetooth devices.\n   * On this web implementation, it only emits ONE device, the one that was selected in the UI (if any).\n   */\n  static listen(observer) {\n    log(\"ble-verbose\", \"listen...\");\n    let unsubscribed;\n    const bluetooth = requiresBluetooth();\n    bluetooth.requestDevice(requestDeviceParam()).then(async device => {\n      if (!unsubscribed) {\n        observer.next({\n          type: \"add\",\n          descriptor: device\n        });\n        observer.complete();\n      }\n    }, error => {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    });\n\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n\n    return {\n      unsubscribe\n    };\n  }\n  /**\n   * open a bluetooth device.\n   */\n\n\n  static async open(deviceOrId) {\n    return open(deviceOrId, true);\n  }\n  /**\n   * globally disconnect a bluetooth device by its id.\n   */\n\n\n  constructor(device, writeCharacteristic, notifyObservable, deviceModel) {\n    super();\n    this.id = void 0;\n    this.device = void 0;\n    this.mtuSize = 20;\n    this.writeCharacteristic = void 0;\n    this.notifyObservable = void 0;\n    this.notYetDisconnected = true;\n    this.deviceModel = void 0;\n\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      try {\n        const msgIn = apdu.toString(\"hex\");\n        log(\"apdu\", `=> ${msgIn}`);\n        const data = await merge(this.notifyObservable.pipe(receiveAPDU), sendAPDU(this.write, apdu, this.mtuSize)).toPromise();\n        const msgOut = data.toString(\"hex\");\n        log(\"apdu\", `<= ${msgOut}`);\n        return data;\n      } catch (e) {\n        log(\"ble-error\", \"exchange got \" + String(e));\n\n        if (this.notYetDisconnected) {\n          // in such case we will always disconnect because something is bad.\n          this.device.gatt.disconnect();\n        }\n\n        throw e;\n      }\n    });\n\n    this.write = async buffer => {\n      log(\"ble-frame\", \"=> \" + buffer.toString(\"hex\"));\n      await this.writeCharacteristic.writeValue(buffer);\n    };\n\n    this.id = device.id;\n    this.device = device;\n    this.writeCharacteristic = writeCharacteristic;\n    this.notifyObservable = notifyObservable;\n    this.deviceModel = deviceModel;\n    log(\"ble-verbose\", `BleTransport(${String(this.id)}) new instance`);\n  }\n\n  async inferMTU() {\n    let mtu = 23;\n    await this.exchangeAtomicImpl(async () => {\n      try {\n        mtu = (await merge(this.notifyObservable.pipe(first(buffer => buffer.readUInt8(0) === 0x08), map(buffer => buffer.readUInt8(5))), defer(() => from(this.write(Buffer.from([0x08, 0, 0, 0, 0])))).pipe(ignoreElements())).toPromise()) + 3;\n      } catch (e) {\n        log(\"ble-error\", \"inferMTU got \" + String(e));\n        this.device.gatt.disconnect();\n        throw e;\n      }\n    });\n\n    if (mtu > 23) {\n      const mtuSize = mtu - 3;\n      log(\"ble-verbose\", `BleTransport(${String(this.id)}) mtu set to ${String(mtuSize)}`);\n      this.mtuSize = mtuSize;\n    }\n\n    return this.mtuSize;\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  setScrambleKey() {}\n\n  async close() {\n    if (this.exchangeBusyPromise) {\n      await this.exchangeBusyPromise;\n    }\n  }\n\n}\n\nBluetoothTransport.isSupported = () => Promise.resolve().then(requiresBluetooth).then(() => true, () => false);\n\nBluetoothTransport.observeAvailability = observer => availability.subscribe(observer);\n\nBluetoothTransport.list = () => Promise.resolve([]);\n\nBluetoothTransport.disconnect = async id => {\n  log(\"ble-verbose\", `user disconnect(${id})`);\n  const transport = transportsCache[id];\n\n  if (transport) {\n    transport.device.gatt.disconnect();\n  }\n};","map":{"version":3,"sources":["../src/TransportWebBLE.js"],"names":["requiresBluetooth","bluetooth","availability","observer","onAvailabilityChanged","e","unsubscribed","available","transportsCache","requestDeviceParam","filters","uuid","services","retrieveService","device","infos","getInfosForServiceUuid","service","log","notifyUuid","Promise","notifyObservable","tap","value","share","notif","transport","onDisconnect","console","id","beforeMTUTime","Date","afterMTUTime","needsReconnect","s","setTimeout","open","BluetoothTransport","isSupported","observeAvailability","list","type","descriptor","error","unsubscribe","disconnect","mtuSize","writeCharacteristic","notYetDisconnected","deviceModel","constructor","String","mtu","merge","first","buffer","map","defer","from","Buffer","ignoreElements","apdu","msgIn","data","sendAPDU","msgOut","setScrambleKey"],"mappings":"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","sourcesContent":["// @flow\n/* eslint-disable prefer-template */\n\nimport Transport from \"@ledgerhq/hw-transport\";\nimport {\n  DisconnectedDevice,\n  TransportOpenUserCancelled,\n} from \"@ledgerhq/errors\";\nimport {\n  getBluetoothServiceUuids,\n  getInfosForServiceUuid,\n} from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { sendAPDU } from \"@ledgerhq/devices/lib/ble/sendAPDU\";\nimport { receiveAPDU } from \"@ledgerhq/devices/lib/ble/receiveAPDU\";\nimport { log } from \"@ledgerhq/logs\";\nimport { Observable, defer, merge, from } from \"rxjs\";\nimport { share, ignoreElements, first, map, tap } from \"rxjs/operators\";\nimport type { Device, Characteristic } from \"./types\";\nimport { monitorCharacteristic } from \"./monitorCharacteristic\";\n\nconst requiresBluetooth = () => {\n  // $FlowFixMe\n  const { bluetooth } = navigator;\n  if (typeof bluetooth === \"undefined\") {\n    throw new Error(\"web bluetooth not supported\");\n  }\n  return bluetooth;\n};\n\nconst availability = (): Observable<boolean> =>\n  Observable.create((observer) => {\n    const bluetooth = requiresBluetooth();\n    const onAvailabilityChanged = (e) => {\n      observer.next(e.value);\n    };\n    bluetooth.addEventListener(\"availabilitychanged\", onAvailabilityChanged);\n    let unsubscribed = false;\n    bluetooth.getAvailability().then((available) => {\n      if (!unsubscribed) {\n        observer.next(available);\n      }\n    });\n    return () => {\n      unsubscribed = true;\n      bluetooth.removeEventListener(\n        \"availabilitychanged\",\n        onAvailabilityChanged\n      );\n    };\n  });\n\nconst transportsCache = {};\n\nconst requestDeviceParam = () => ({\n  filters: getBluetoothServiceUuids().map((uuid) => ({\n    services: [uuid],\n  })),\n});\n\nconst retrieveService = async (device) => {\n  if (!device.gatt) throw new Error(\"bluetooth gatt not found\");\n  const [service] = await device.gatt.getPrimaryServices();\n  if (!service) throw new Error(\"bluetooth service not found\");\n  const infos = getInfosForServiceUuid(service.uuid);\n  if (!infos) throw new Error(\"bluetooth service infos not found\");\n  return [service, infos];\n};\n\nasync function open(deviceOrId: Device | string, needsReconnect: boolean) {\n  let device;\n  if (typeof deviceOrId === \"string\") {\n    if (transportsCache[deviceOrId]) {\n      log(\"ble-verbose\", \"Transport in cache, using that.\");\n      return transportsCache[deviceOrId];\n    }\n\n    const bluetooth = requiresBluetooth();\n\n    // TODO instead we should \"query\" the device by its ID\n    device = await bluetooth.requestDevice(requestDeviceParam());\n  } else {\n    device = deviceOrId;\n  }\n\n  if (!device.gatt.connected) {\n    log(\"ble-verbose\", \"not connected. connecting...\");\n    await device.gatt.connect();\n  }\n\n  const [service, infos] = await retrieveService(device);\n  const { deviceModel, writeUuid, notifyUuid } = infos;\n  const [writeC, notifyC] = await Promise.all([\n    service.getCharacteristic(writeUuid),\n    service.getCharacteristic(notifyUuid),\n  ]);\n\n  const notifyObservable = monitorCharacteristic(notifyC).pipe(\n    tap((value) => {\n      log(\"ble-frame\", \"<= \" + value.toString(\"hex\"));\n    }),\n    share()\n  );\n\n  const notif = notifyObservable.subscribe();\n\n  const transport = new BluetoothTransport(\n    device,\n    writeC,\n    notifyObservable,\n    deviceModel\n  );\n\n  if (!device.gatt.connected) {\n    throw new DisconnectedDevice();\n  }\n\n  // eslint-disable-next-line require-atomic-updates\n  transportsCache[transport.id] = transport;\n  const onDisconnect = (e) => {\n    console.log(\"onDisconnect!\", e);\n    delete transportsCache[transport.id];\n    transport.notYetDisconnected = false;\n    notif.unsubscribe();\n    device.removeEventListener(\"gattserverdisconnected\", onDisconnect);\n    log(\"ble-verbose\", `BleTransport(${transport.id}) disconnected`);\n    transport.emit(\"disconnect\", e);\n  };\n  device.addEventListener(\"gattserverdisconnected\", onDisconnect);\n\n  let beforeMTUTime = Date.now();\n  try {\n    await transport.inferMTU();\n  } finally {\n    let afterMTUTime = Date.now();\n\n    // workaround for #279: we need to open() again if we come the first time here,\n    // to make sure we do a disconnect() after the first pairing time\n    // because of a firmware bug\n\n    if (afterMTUTime - beforeMTUTime < 1000) {\n      needsReconnect = false; // (optim) there is likely no new pairing done because mtu answer was fast.\n    }\n\n    if (needsReconnect) {\n      await device.gatt.disconnect();\n      // necessary time for the bonding workaround\n      await new Promise((s) => setTimeout(s, 4000));\n    }\n  }\n\n  if (needsReconnect) {\n    return open(device, false);\n  }\n\n  return transport;\n}\n\n/**\n * react-native bluetooth BLE implementation\n * @example\n * import BluetoothTransport from \"@ledgerhq/hw-transport-web-ble\";\n */\nexport default class BluetoothTransport extends Transport<Device | string> {\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve()\n      .then(requiresBluetooth)\n      .then(\n        () => true,\n        () => false\n      );\n\n  /**\n   * observe event with { available: bool, type: string }\n   * (available is generic, type is specific)\n   * an event is emit once and then each time it changes\n   */\n  static observeAvailability = (observer: *) =>\n    availability.subscribe(observer);\n\n  static list = (): * => Promise.resolve([]);\n\n  /**\n   * Scan for Ledger Bluetooth devices.\n   * On this web implementation, it only emits ONE device, the one that was selected in the UI (if any).\n   */\n  static listen(observer: *) {\n    log(\"ble-verbose\", \"listen...\");\n    let unsubscribed;\n\n    const bluetooth = requiresBluetooth();\n\n    bluetooth.requestDevice(requestDeviceParam()).then(\n      async (device) => {\n        if (!unsubscribed) {\n          observer.next({\n            type: \"add\",\n            descriptor: device,\n          });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  }\n\n  /**\n   * open a bluetooth device.\n   */\n  static async open(deviceOrId: Device | string) {\n    return open(deviceOrId, true);\n  }\n\n  /**\n   * globally disconnect a bluetooth device by its id.\n   */\n  static disconnect = async (id: *) => {\n    log(\"ble-verbose\", `user disconnect(${id})`);\n    const transport = transportsCache[id];\n    if (transport) {\n      transport.device.gatt.disconnect();\n    }\n  };\n\n  id: string;\n\n  device: Device;\n\n  mtuSize: number = 20;\n\n  writeCharacteristic: Characteristic;\n\n  notifyObservable: Observable<Buffer>;\n\n  notYetDisconnected = true;\n\n  deviceModel: DeviceModel;\n\n  constructor(\n    device: Device,\n    writeCharacteristic: Characteristic,\n    notifyObservable: Observable<*>,\n    deviceModel: DeviceModel\n  ) {\n    super();\n    this.id = device.id;\n    this.device = device;\n    this.writeCharacteristic = writeCharacteristic;\n    this.notifyObservable = notifyObservable;\n    this.deviceModel = deviceModel;\n\n    log(\"ble-verbose\", `BleTransport(${String(this.id)}) new instance`);\n  }\n\n  async inferMTU() {\n    let mtu = 23;\n\n    await this.exchangeAtomicImpl(async () => {\n      try {\n        mtu =\n          (await merge(\n            this.notifyObservable.pipe(\n              first((buffer) => buffer.readUInt8(0) === 0x08),\n              map((buffer) => buffer.readUInt8(5))\n            ),\n            defer(() => from(this.write(Buffer.from([0x08, 0, 0, 0, 0])))).pipe(\n              ignoreElements()\n            )\n          ).toPromise()) + 3;\n      } catch (e) {\n        log(\"ble-error\", \"inferMTU got \" + String(e));\n        this.device.gatt.disconnect();\n        throw e;\n      }\n    });\n\n    if (mtu > 23) {\n      const mtuSize = mtu - 3;\n      log(\n        \"ble-verbose\",\n        `BleTransport(${String(this.id)}) mtu set to ${String(mtuSize)}`\n      );\n      this.mtuSize = mtuSize;\n    }\n\n    return this.mtuSize;\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      try {\n        const msgIn = apdu.toString(\"hex\");\n        log(\"apdu\", `=> ${msgIn}`);\n\n        const data = await merge(\n          this.notifyObservable.pipe(receiveAPDU),\n          sendAPDU(this.write, apdu, this.mtuSize)\n        ).toPromise();\n\n        const msgOut = data.toString(\"hex\");\n        log(\"apdu\", `<= ${msgOut}`);\n\n        return data;\n      } catch (e) {\n        log(\"ble-error\", \"exchange got \" + String(e));\n        if (this.notYetDisconnected) {\n          // in such case we will always disconnect because something is bad.\n          this.device.gatt.disconnect();\n        }\n        throw e;\n      }\n    });\n\n  setScrambleKey() {}\n\n  write = async (buffer: Buffer) => {\n    log(\"ble-frame\", \"=> \" + buffer.toString(\"hex\"));\n    await this.writeCharacteristic.writeValue(buffer);\n  };\n\n  async close() {\n    if (this.exchangeBusyPromise) {\n      await this.exchangeBusyPromise;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}